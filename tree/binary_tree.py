from Queue import Queue

from typing import TypeVar, Generic, Generator, Optional, List

# use generics to construct node
T = TypeVar("T")


class TreeNode(Generic[T]):
    def __init__(self, value):
        # type: (T) -> None
        self.val = value
        self.left = None
        self.right = None


########################################
# traversal                            #
# use generator to implement recursion #
########################################

# Pre-order traversal
def pre_order(root):
    # type: (Optional[TreeNode[T]]) -> Generator[T, None, None]
    if root:
        yield root.val
        # In Python3, we can use nested generator like this:
        # yield from pre_order(root.left)
        # yield from pre_order(root.right)

        # In Python2, we should manual iterate
        for node in pre_order(root.left):
            yield node  # node already has been object generated by generator
        for node in pre_order(root.right):
            yield node
    else:
        return


# In-order traversal
def in_order(root):
    # type: (Optional[TreeNode[T]]) -> Generator[T, None, None]
    if root:
        for node in in_order(root.left):
            yield node
        yield root.val
        for node in in_order(root.right):
            yield node
    else:
        return


# In-order traversal
def post_order(root):
    # type: (Optional[TreeNode[T]]) -> Generator[T, None, None]
    if root:
        for node in post_order(root.left):
            yield node
        for node in post_order(root.right):
            yield node
        yield root.val
    else:
        return


#######################
# add more operations #
#######################

def reverse_tree(root):  # type: (Optional[TreeNode[T]]) -> None
    """
    reverse all subtree of tree, use recursive
    :param root: root node of a tree
    :return:
    """
    if root is not None:
        root.left, root.right = root.right, root.left
        reverse_tree(root.left)
        reverse_tree(root.right)
    else:
        return


def get_num(root):  # type: (Optional[TreeNode[T]]) -> int
    """
    use bfs to count total number of node
    :param root: root node
    :return: node number
    """
    if root is None:
        return 0
    else:
        q = Queue()
        count = 0
        q.put(root)
        while not q.empty():
            n = q.get()
            count += 1
            if n.left:
                q.put(n.left)
            # equal relationship, no elif
            if n.right:
                q.put(n.right)
        return count


def is_symmetrical(root):  # type: (Optional[TreeNode[T]]) -> bool
    """
    judge if tree is a symmetrical structure
    :param root: root node
    :return: bool
    """
    if root is None:
        return True
    num = get_num(root)
    if num % 2 == 0:  # even number must be asymmetry
        return False
    else:
        return check_subtree_symmetrical(root.left, root.right)


def check_subtree_symmetrical(left, right):  # type: (Optional[TreeNode[T]],Optional[TreeNode[T]]) -> bool
    """
    recurse check subtree symmetrical
    :param left:
    :param right:
    :return:
    """
    if not left:  # left child is None, symmetry require right child is None, too
        return right is None
    if not right:  # left child is not None, but right child is None, must be asymmetry
        return False
    if left.val != right.val:  # compare children value
        return False
    return check_subtree_symmetrical(left.right, right.left) and check_subtree_symmetrical(left.left, right.right)


def get_width(root):  # type: (Optional[TreeNode[T]]) -> int
    """
    use bfs to calculate max number of every level
    :param root:
    :return:
    """
    if root is None:
        return 0
    q = Queue()
    q.put(root)
    width = 1
    q_depth = 1  # every level's number
    while not q.empty():
        while q_depth:
            n = q.get()
            if n.left:
                q.put(n.left)
            if n.right:
                q.put(n.right)
            q_depth -= 1
        q_depth = q.qsize()  # qsize(): approximate size because synchronization problem, but single thread is accurate
        width = max(width, q_depth)
    return width


def re_construct(pre_order_list, in_order_list):  # type: (Optional[list], Optional[list]) -> Optional[TreeNode[T]]
    """
    re-construct a tree according to its traversal lists
    :param pre_order_list:
    :param in_order_list:
    :return: re-construct tree's root node
    """
    if pre_order_list is None or in_order_list is None or (not len(pre_order_list)) or (not len(in_order_list)):
        return None
    root = TreeNode(pre_order_list[0])  # pre_order list's first node is root node
    # find root node in in_order list, the first one must be root node
    index = in_order_list.index(pre_order_list[0])
    # left_in = left_pre = right_in = right_pre = [] # error: this cause variable use same object
    left_in = []
    left_pre = []
    right_in = []
    right_pre = []
    # according to root node's index to spilt order list into left and right two part
    left_in.extend(in_order_list[:index])
    left_pre.extend(pre_order_list[1:index + 1])
    right_in.extend(in_order_list[index + 1:])
    right_pre.extend(pre_order_list[index + 1:])

    # recurse get subtree's root node
    root.left = re_construct(left_pre, left_in)
    root.right = re_construct(right_pre, right_in)
    return root


def find_max_distance(root):  # type: (TreeNode) -> int
    """
    find max distance between arbitrary two node
    :param root:
    :return:
    """

    def _recur_find(node):  # type: (TreeNode) -> (int, int)
        """
        recursive find max distance and max depth of current tree
        :param node:current root of tree
        :return:(max_distance, max_depth)
        """
        if node is None:
            return 0, -1  # null node's depth is -1, and left node's depth is 0
        lmd = _recur_find(node.left)
        rmd = _recur_find(node.right)
        max_dist = max(lmd[1] + rmd[1] + 2, max(lmd[0], rmd[0]))  # update max distance
        max_depth = max(lmd[1], rmd[1]) + 1  # update max depth
        return max_dist, max_depth

    return _recur_find(root)[0]


def find_max_distance_opti(root):  # type: (TreeNode) -> int
    """
    find max distance between arbitrary two node without transfer max distance
    :param root:
    """
    md = [0]  # use to store max distance, py2.7 not support 'nolocal', so use list to replace

    def _recur_find(node):
        if node is None:
            return -1
        lmd = _recur_find(node.left) + 1
        rmd = _recur_find(node.right) + 1
        md[0] = max(md[0], lmd + rmd)  # update max distance
        return max(lmd, rmd)  # return max depth

    _recur_find(root)
    return md[0]


def num_trees(n):  # type: (int) -> int
    """
    use dynamic-programming to calculate unique BST number by using 1...n
    :param n:
    :return:
    """
    count = [0] * (n + 1)
    count[0] = 1
    count[1] = 1
    for i in range(2, n + 1):  # calculate count in turn
        for j in range(i):  # every count contain several segmentation
            count[i] += count[j] * count[i - j - 1]
    return count[n]


def num_and_generate_trees(n):  # type: (int) -> List[TreeNode[int]]
    """
    generate all unique BST and generate all possible
    :param n:
    """

    def _generate_trees(start, end):
        # type: (int, int) -> List[TreeNode[int]]
        res = []
        if start > end:
            res.append(None)
            return res
        for i in range(start, end + 1):  # i is root node
            left = _generate_trees(start, i - 1)
            right = _generate_trees(i + 1, end)

            for l in left:
                for r in right:  # traverse all possible combination
                    root = TreeNode(i)
                    root.left = l
                    root.right = r
                    res.append(root)
        return res

    if n == 0:
        return []
    else:
        return _generate_trees(1, n)


if __name__ == '__main__':
    singer = TreeNode("Taylor Swift")

    genre_country = TreeNode("Country")
    genre_pop = TreeNode("Pop")

    album_fearless = TreeNode("Fearless")
    album_red = TreeNode("Red")
    album_1989 = TreeNode("1989")
    album_reputation = TreeNode("Reputation")

    song_ls = TreeNode("Love Story")
    song_wh = TreeNode("White Horse")
    song_wanegbt = TreeNode("We Are Never Ever Getting Back Together")
    song_ikywt = TreeNode("I Knew You Were Trouble")
    song_sio = TreeNode("Shake It Off")
    song_bb = TreeNode("Bad Blood")
    song_lwymmd = TreeNode("Look What You Made Me Do")
    song_g = TreeNode("Gorgeous")

    singer.left, singer.right = genre_country, genre_pop
    genre_country.left, genre_country.right = album_fearless, album_red
    genre_pop.left, genre_pop.right = album_1989, album_reputation
    album_fearless.left, album_fearless.right = song_ls, song_wh
    album_red.left, album_red.right = song_wanegbt, song_ikywt
    album_1989.left, album_1989.right = song_sio, song_bb
    album_reputation.left, album_reputation.right = song_lwymmd, song_g

    print(list(pre_order(singer)))
    print(list(in_order(singer)))
    print(list(post_order(singer)))

    root_node = TreeNode(0)
    child_node1_1 = TreeNode(1)
    child_node1_2 = TreeNode(1)
    child_node2_1 = TreeNode(2)
    child_node2_2 = TreeNode(3)
    child_node2_3 = TreeNode(4)
    child_node2_4 = TreeNode(2)
    child_node3_1 = TreeNode(3)

    root_node.left, root_node.right = child_node1_1, child_node1_2
    child_node1_1.left, child_node1_1.right = child_node2_1, child_node2_2
    child_node1_2.left, child_node1_2.right = child_node2_3, child_node2_4
    child_node2_1.left = child_node3_1

    print("Max Distance:", find_max_distance(root_node))
    print("Max Distance:", find_max_distance_opti(root_node))

    print(list(in_order(root_node)))

    reverse_tree(root_node)
    print(list(in_order(root_node)))

    print("is symmetrical:", is_symmetrical(root_node))
    child_node2_3.val = 3
    print(list(in_order(root_node)))
    print("is symmetrical:", is_symmetrical(root_node))

    print("Tree number:", get_num(root_node))
    print("Tree width:", get_width(root_node))

    # use list() to change generator to list
    child_node2_2.val = 2
    print(list(in_order(root_node)))
    re_root = re_construct(list(pre_order(root_node)), list(in_order(root_node)))
    print(list(in_order(re_root)))

    print(num_trees(5))
    trees = num_and_generate_trees(5)
    for tree in trees:
        print(list(pre_order(tree)))
